-- *** CREATE TABLES AND SECUENCES *** ---

-- PERSON
ALTER SESSION SET CONTAINER=XEPDB1;

GRANT ALL PRIVILEGES TO appuser CONTAINER=CURRENT;
ALTER USER appuser DEFAULT TABLESPACE users TEMPORARY TABLESPACE temp QUOTA UNLIMITED ON users;

CREATE TABLE APPUSER.PERSON (
	PERSON NUMBER,
	EMAIL VARCHAR2(100) NOT NULL,
	PASSWORD VARCHAR2(1000) NOT NULL,
	PERSON_TOKEN VARCHAR2(1000) NOT NULL,
	FIRST_NAME VARCHAR2(100) NOT NULL,
	LAST_NAME VARCHAR2(100) NOT NULL,
	ADD_DATE DATE DEFAULT SYSDATE,
	PRIMARY KEY(PERSON)
);


CREATE SEQUENCE APPUSER.SQ_PERSON NOCACHE;


-- BANK
CREATE TABLE APPUSER.BANK (
	BANK NUMBER,
	BANK_NAME VARCHAR2(100),
	PRIMARY KEY(BANK)
);

CREATE SEQUENCE APPUSER.SQ_BANK NOCACHE;

INSERT INTO APPUSER.BANK(BANK, BANK_NAME) VALUES (APPUSER.SQ_BANK.NEXTVAL, 'GyT Continental');
INSERT INTO APPUSER.BANK(BANK, BANK_NAME) VALUES (APPUSER.SQ_BANK.NEXTVAL, 'Promerica');
INSERT INTO APPUSER.BANK(BANK, BANK_NAME) VALUES (APPUSER.SQ_BANK.NEXTVAL, 'Banco Industrial');



-- CURRENCIE
CREATE TABLE APPUSER.CURRENCIE (
	CURRENCIE NUMBER,
	CURRENCIE_NAME VARCHAR2(50),
	CURRENCIE_SYMBOL VARCHAR2(5),
	PRIMARY KEY(CURRENCIE)
);

CREATE SEQUENCE APPUSER.SQ_CURRENCIE NOCACHE;

INSERT INTO APPUSER.CURRENCIE(CURRENCIE,CURRENCIE_NAME, CURRENCIE_SYMBOL) VALUES (APPUSER.SQ_CURRENCIE.NEXTVAL, 'United States Dollar', 'USD');
INSERT INTO APPUSER.CURRENCIE(CURRENCIE,CURRENCIE_NAME, CURRENCIE_SYMBOL) VALUES (APPUSER.SQ_CURRENCIE.NEXTVAL, 'Mexican Peso', 'MXN');
INSERT INTO APPUSER.CURRENCIE(CURRENCIE,CURRENCIE_NAME, CURRENCIE_SYMBOL) VALUES (APPUSER.SQ_CURRENCIE.NEXTVAL, 'Guatemalan Quetzal', 'GTQ');

-- BANK ACCOUNT
CREATE TABLE APPUSER.BANK_ACCOUNT (
	BANK_ACCOUNT VARCHAR2(50),
	BANK_NAME NUMBER,
	PERSON_ACCOUNT NUMBER,
	AMOUNT NUMBER,
	CURRENCIE NUMBER,
	ADD_DATE DATE DEFAULT SYSDATE,
	MOD_DATE DATE,
	PRIMARY KEY(BANK_ACCOUNT),
	FOREIGN KEY(BANK_NAME) REFERENCES APPUSER.BANK(BANK),
	FOREIGN KEY(PERSON_ACCOUNT) REFERENCES APPUSER.PERSON(PERSON),
	FOREIGN KEY(CURRENCIE) REFERENCES APPUSER.CURRENCIE(CURRENCIE)
);

-- RECORD TYPE
CREATE TABLE APPUSER.RECORD_TYPE (
	RECORD_TYPE NUMBER,
	RECORD_TYPE_NAME VARCHAR2(25),
	PRIMARY KEY (RECORD_TYPE)
);

INSERT INTO APPUSER.RECORD_TYPE(RECORD_TYPE, RECORD_TYPE_NAME) VALUES (1, 'Incomes');
INSERT INTO APPUSER.RECORD_TYPE(RECORD_TYPE, RECORD_TYPE_NAME) VALUES (2, 'Expenses');

-- CATEGORY 
CREATE TABLE APPUSER.CATEGORY (
	CATEGORY NUMBER,
	CATEGORY_TYPE NUMBER,
	CATEGORY_NAME VARCHAR2(25),
	PRIMARY KEY (CATEGORY),
	FOREIGN KEY (CATEGORY_TYPE) REFERENCES APPUSER.RECORD_TYPE(RECORD_TYPE)
);

CREATE SEQUENCE APPUSER.SQ_CATEGORY NOCACHE;

INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (1, 1, 'Work');
INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (3, 1, 'Transfer In');
INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (4, 2, 'Transfer Out');
INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (7, 2, 'Emergency');
INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (5, 2, 'Hoby');
INSERT INTO APPUSER.CATEGORY(CATEGORY, CATEGORY_TYPE, CATEGORY_NAME) VALUES  (6, 1, 'Gift');

-- RECORD HISTORY
CREATE TABLE APPUSER.RECORD_HISTORY (
	RECORD_HISTORY NUMBER,
	RECORD_TYPE NUMBER,
	BANK_ACCOUNT VARCHAR2(50),
	CATEGORY NUMBER,
	AMOUNT NUMBER,
	DESCRIPTION VARCHAR2(50),
	RECORD_DATE DATE DEFAULT SYSDATE,
	PRIMARY KEY (RECORD_HISTORY),
	FOREIGN KEY (RECORD_TYPE) REFERENCES APPUSER.RECORD_TYPE(RECORD_TYPE),
	FOREIGN KEY (BANK_ACCOUNT) REFERENCES APPUSER.BANK_ACCOUNT(BANK_ACCOUNT),
	FOREIGN KEY (CATEGORY) REFERENCES APPUSER.CATEGORY(CATEGORY)
);

CREATE SEQUENCE APPUSER.SQ_RECORD;

--  *** FUNCTIONS *** ---
-- API TOKEN

CREATE OR REPLACE FUNCTION APPUSER.API_TOKEN(PSECRET VARCHAR2) RETURN VARCHAR2
IS 
	VRESULT VARCHAR2(4000);
BEGIN
		SELECT UTL_RAW.CAST_TO_VARCHAR2(UTL_I18N.STRING_TO_RAW(STANDARD_HASH(PSECRET, 'MD5' ), 'AL32UTF8')) INTO VRESULT FROM DUAL;
		RETURN VRESULT;
END API_TOKEN;
/

-- RECORD INCOME
CREATE OR REPLACE FUNCTION APPUSER.RECORD_INCOME(BANK_ACCOUNT_API VARCHAR2, CATEGORY NUMBER, AMOUNT_API NUMBER,  DESCRIPTION VARCHAR2) RETURN VARCHAR2
IS 
	STATUS_TRANSACTION VARCHAR2(500);
BEGIN
	INSERT INTO APPUSER.RECORD_HISTORY VALUES(SQ_RECORD.NEXTVAL, 1, BANK_ACCOUNT_API, CATEGORY, AMOUNT_API, DESCRIPTION, SYSDATE);
	UPDATE APPUSER.BANK_ACCOUNT 
		SET AMOUNT = AMOUNT + AMOUNT_API, MOD_DATE = SYSDATE
	WHERE BANK_ACCOUNT = BANK_ACCOUNT_API;
	COMMIT;
	STATUS_TRANSACTION :='commit';
	RETURN(STATUS_TRANSACTION);
EXCEPTION
	WHEN OTHERS THEN
	ROLLBACK;
	STATUS_TRANSACTION :='rollback';
	RETURN(STATUS_TRANSACTION);
END RECORD_INCOME;
/
-- RECORD EXPENSE 

CREATE OR REPLACE FUNCTION APPUSER.RECORD_EXPENSE(BANK_ACCOUNT_API VARCHAR2, CATEGORY NUMBER, AMOUNT_API NUMBER, DESCRIPTION VARCHAR2) RETURN VARCHAR2
IS 
	STATUS_TRANSACTION VARCHAR2(500);
	AMOUNT_BANK NUMBER;
BEGIN
	--Traemos el dinero que tiene la cuenta 
	SELECT AMOUNT INTO AMOUNT_BANK FROM APPUSER.BANK_ACCOUNT WHERE BANK_ACCOUNT=BANK_ACCOUNT_API;
	-- Verificamos si podemos retarle a la cuenta
	IF AMOUNT_BANK >= AMOUNT_API THEN
		-- Ingresamos un nuevo registro en record
		INSERT INTO APPUSER.RECORD_HISTORY VALUES(SQ_RECORD.NEXTVAL, 2, BANK_ACCOUNT_API, CATEGORY, AMOUNT_API, DESCRIPTION, SYSDATE);
		-- Restamos dinero a la cuenta
		UPDATE APPUSER.BANK_ACCOUNT 
			SET AMOUNT = AMOUNT - AMOUNT_API, MOD_DATE = SYSDATE
		WHERE BANK_ACCOUNT = BANK_ACCOUNT_API;
		--Guardamos los cambios
		COMMIT;
		--Retornamos el estado de la transaccion
		STATUS_TRANSACTION :='commit';
		RETURN(STATUS_TRANSACTION);
	ELSIF AMOUNT_BANK < AMOUNT_API THEN
		COMMIT;
		STATUS_TRANSACTION :='undo';
		RETURN(STATUS_TRANSACTION);
	END IF;
-- Si ocurre un error, hacemos rollback
EXCEPTION
	WHEN OTHERS THEN
	ROLLBACK;
	--Regresamos el estado de la transaccion
	STATUS_TRANSACTION :='rollback';
	RETURN(STATUS_TRANSACTION);
END RECORD_EXPENSE;
/
-- TRANSFER MONEY 

CREATE OR REPLACE FUNCTION APPUSER.TRANSFER_MONEY(BANK_ACCOUNT_OUT VARCHAR2, BANK_ACCOUNT_IN VARCHAR2, AMOUNT_OUT NUMBER, AMOUNT_IN NUMBER, DESCRIPTION VARCHAR2) RETURN VARCHAR2
IS 
	STATUS_TRANSACTION VARCHAR2(500);
	AMOUNT_BANK NUMBER;
BEGIN
	--Traemos el dinero que tiene la cuenta 
	SELECT AMOUNT INTO AMOUNT_BANK FROM APPUSER.BANK_ACCOUNT WHERE BANK_ACCOUNT=BANK_ACCOUNT_OUT;
	-- Verificamos si podemos retarle a la cuenta
	IF AMOUNT_BANK >= AMOUNT_OUT THEN
		-- Ingresamos un nuevo registro en record 2 para expense y 4 para transfer out
		INSERT INTO APPUSER.RECORD_HISTORY VALUES(SQ_RECORD.NEXTVAL, 2, BANK_ACCOUNT_OUT, 4, AMOUNT_OUT, DESCRIPTION, SYSDATE);
		-- Restamos dinero a la cuenta
		UPDATE APPUSER.BANK_ACCOUNT 
			SET AMOUNT = AMOUNT - AMOUNT_OUT, MOD_DATE = SYSDATE
		WHERE BANK_ACCOUNT = BANK_ACCOUNT_OUT;
	
		--Transferimos el dinero a la siguiente cuenta
		-- Ingresamos un nuevo registro en record 2 para expense y 3 para transfer
		INSERT INTO APPUSER.RECORD_HISTORY VALUES(SQ_RECORD.NEXTVAL, 1, BANK_ACCOUNT_IN, 3, AMOUNT_IN, DESCRIPTION, SYSDATE);
		-- Restamos dinero a la cuenta
		UPDATE APPUSER.BANK_ACCOUNT 
			SET AMOUNT = AMOUNT + AMOUNT_IN, MOD_DATE = SYSDATE
		WHERE BANK_ACCOUNT = BANK_ACCOUNT_IN;
		--Guardamos los cambios
		COMMIT;
		--Retornamos el estado de la transaccion
		STATUS_TRANSACTION :='commit';
		RETURN(STATUS_TRANSACTION);
	ELSIF AMOUNT_BANK < AMOUNT_OUT THEN
		COMMIT;
		STATUS_TRANSACTION :='undo';
		RETURN(STATUS_TRANSACTION);
	END IF;
-- Si ocurre un error, hacemos rollback
EXCEPTION
	WHEN OTHERS THEN
	ROLLBACK;
	--Regresamos el estado de la transaccion
	STATUS_TRANSACTION :='rollback';
	RETURN(STATUS_TRANSACTION);
END TRANSFER_MONEY;
/

